:LATEX_SETTINGS:
#+EXPORT_FILE_NAME: bca-sujal-gurung-34-project1-report
#+BIBLIOGRAPHY: bibliography.bib
#+LATEX_HEADER: \pagenumbering{roman}
#+LATEX_HEADER: \graphicspath{{/home/sujal/programming/college-files/assets/images/}}

#+BIBLIOGRAPHY: bibliography.bib
#+OPTIONS: toc:nil
#+LATEX_HEADER: \author{Sujal Gurung 6-2-378-82-2020}
#+LATEX_HEADER: \date{\today}

#+LATEX_HEADER: \usepackage[margin=1in, left=1.25in]{geometry}
#+LATEX_HEADER: \usepackage{placeins}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage{svg}
#+LATEX_HEADER: \usepackage[acronym]{glossaries}
#+LATEX_HEADER: \makeglossaries

#+LaTeX_CLASS: article
#+LATEX_HEADER: \AddToHook{cmd/section/before}{\clearpage}
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LaTeX_HEADER: \setstretch{1.5}
#+LaTeX_HEADER: \usepackage{times}
#+LaTeX_HEADER: \usepackage[12pt]{moresize}
#+LaTeX_HEADER: \AtBeginDocument{\fontsize{12}{15}\selectfont}
#+LaTeX_HEADER: \usepackage{titlesec}
#+LaTeX_HEADER: \titleformat{\chapter}{\bfseries\fontsize{16}{18}\selectfont}{\thechapter}{1em}{}
#+LaTeX_HEADER: \titleformat{\section}{\bfseries\fontsize{14}{16}\selectfont}{\thesection}{1em}{}
#+LaTeX_HEADER: \titleformat{\subsection}{\bfseries\fontsize{12}{14}\selectfont}{\thesubsection}{1em}{}
#+LaTeX_HEADER: \usepackage{caption}
#+LaTeX_HEADER: \DeclareCaptionFormat{myformat}{\fontsize{12}{12}\selectfont\bfseries#1#2#3}
#+LaTeX_HEADER: \captionsetup{format=myformat,justification=centering}
#+LaTeX_HEADER: \captionsetup[figure]{position=bottom}
#+LaTeX_HEADER: \captionsetup[table]{position=top}
:END:
:export-titlepage:
# !!!!!!!!!!!!            don't edit
\begin{large}

\makeatletter
\begin{titlepage}
\centering
\includegraphics[scale=0.5]{tu-logo-transparent} 
\vfill

\textbf{\Large{Tribhuvan University \\Faculty of Humanities and Social Sciences\\}}
\vfill

\textbf{\Large{A Project report on: \\CardsQL \\- A flashcard revision/quiz app }}
\vfill

\textbf{Submitted to: \\Department of Computer Application, \\ Himalaya College of Engineering, \\Chyasal,Lalitpur}
\vfill

\textbf{\emph{In partial fulfillment of the requirements for the Bachelors in Computer Application}}

\textbf{Submitted by:}\\\@author\\\@date\\
\vfill

Under the Supervision of
\textbf{<Supervisor name>}

\makeatother
\end{titlepage}
\end{large}
\clearpage
:end:
:acronyms:
#+BEGIN_EXPORT latex
%% \newacronym{label}{abbreviation}{full form} 
\newacronym{html}{HTML}{Hyper Text Markup Language}
\newacronym{css}{CSS}{Cascading Style Sheets}
\newacronym{crud}{CRUD}{Create, Read, Update, Delete}
\newacronym{rdbms}{RDBMS}{Relational Database Management System}
\newacronym{case}{CASE}{Computer Aided Software Engineering}
\newacronym{sql}{SQL}{Structured Query Language}
\newacronym{http}{HTTP}{Hyper Text Transfer Protocol}


%% list of acronyms is created right before introduction
%%%% usage options:
% \acrlong{label}    
% \acrshort{label}
% \acrfull{label}   => prints both short & long form
#+END_EXPORT
:end:
* COMMENT TODOS
- [ ] use svg outputs
- [ ] when creating or making changes to plantuml blocks, execute it to generate output file
  - [ ] don't execute blocks when exporting entire file though
- [X] bibliography using =./bibliography.bib= file
- [X] fix padding for references after 1st reference
- [ ] ask Himal sir about differences between Abstract & intro
- [ ] search for "TODO" or "COMMENT" in this doc
* COMMENT Certificate Page
# this has specific format. write in libreOffice & print separately?
# or maybe there's a way to include pdfs while exporting
# use this [[https://old.reddit.com/r/orgmode/comments/meuqtb/attaching_pdfs_in_a_org_mode_document/gsk3z1y/][link]]
** Supervisor recommendation
\clearpage
** Internal and External Examiners' Approval Letter
\clearpage
* Abstract
:PROPERTIES:
:UNNUMBERED: t
:END:
Traditional study techniques of just reading through books, course materials are *passive* and don't engage our minds
too much. Students may not be able to retain studied information for long periods of time, due to the way our brains work.

*Flashcards* are an alternative solution for retaining information by remembering facts or answers to questions. 
The reasoning being that retreiving previously learned information from our memory engages our brains,
strengthens the neural connections to that info and thus, we can remember it easier the next time.

This reflects real world scenarios like exams and tests how much of our learning we actually remember.
Practicing flashcards from time to time can be a simple but effective form of revision.
CardsQL implements this in an easy-to-use web interface with some additional quality of life features.

* Acknowledgement
:PROPERTIES:
:UNNUMBERED: t
:END:

#+begin_export latex
\singlespacing
  \clearpage \tableofcontents \clearpage
\onehalfspacing
\listoffigures
\listoftables
\printglossaries
\printglossary[type=\acronymtype,title=Acronyms]

% \printglossaries[type=\acronymtype]
#+END_EXPORT
* Introduction
#+LATEX:\pagenumbering{arabic}
** Introduction
Flashcards are a simple way for students to revise topics. On a piece of paper, we write a question on one side
and then the answer on the next. The following is an example of what a flashcard might look like:

#+CAPTION:Example Flashcard
[[file:../proposal/diagrams/flashcard-example.png]]


To utilize this flashcard, we would read the question & try to remember the answer.
Then, flip the card over & see how well we remembered it.
CardsQL is a web app that digitises this technique. The name is derived from a combination of Flashcards & SQL.

** Problem Statement
+ *inefficient traditional studying techniques*

+ *inconvenient to manage physical flashcards*   
  - Physical flashcards will eventually get damaged or wear out.
    It may also be impractical to store or carry around a large number of cards. 
  - Storing cards digitally allows them to be physically secure & portable.

+ *cumbersome to schedule, keep track of next repition for cards*   
  - After reviewing/ recalling a card, we need to schedule when to practice it again.
    We not only need to keep track of its schedule, but also remember to review it on that day.
    If we forget to do so, then keeping track of overdue cards adds another layer of unneeded complexity.

** Objectives
- provide as easy of an entry point to flashcard programs by keeping things simple 
- provide intuitive interface so that user doesn't have to understand how the system works in order to utilize it
- automate scheduling of next review. Users just have to use it & practice flashcards regularly.
- allow editing creadted cards' contents & review date
# - allow creating different types of flashcards & categorizing them by subject/ tag
** Scope and Limitaiton
*** Scope
CardsQL would be appropriate for the following types of users:
- Students ranging from high schooolers to Doctorates, as they have to understand and memorize a lot of concepts.
- People learning a new language. Applications like *Dulingo, Anki* that use question-answer based learning are popularly
  used for this purpose.
- People, in general, that want to retain their knowledge.
*** Limitation
- Cards are stored locally on users' computer so there are no cloud backup or multi-device synchronization features. 
  Users can implement it manually if they wish using services like *Dropbox* or *Syncthing*.
- Initial setup process of installing dependencies and running a web server from the command line may be jarring for
  non-technical users.
- Databse backups haven't been implemented due to time constraints.
- Currently, all flashcards are stored in a single table in the database. This may become unorganized after a large number
  of cards are added.
** TODO Report Organization
# summary of each following chapter and its contents
* Background Study and Literature Review
** Background Study
# description of fundamental theories, general concepts, terminologies related to the project
*** Active Recall
Cognitive researchers have found that trying to recall facts strengthens the relevant neural connections in our brain
& thus, allows us to remember it for longer periods of time. This process is specifically called *Active Recall* & is proven to be more effective than passive studying[cite:@active_recall]. 

*** Spaced Repitition
Hermann Ebbinghaus, a German psychologist, concluded after extensive research
that as time passes, our ability to rememeber a piece of information slowly decreases[cite:@spaced_repitition].
He called this the forgetting curve.

#+CAPTION:Ebbinghaus' forgetting curve 
#+attr_latex: :height 200px
#+attr_org: :height 200px
[[file:diagrams/forgetting-curve.png]]

Ebbinghaus discovered that performing Active Recall at increasing time intervals would increase memory retention & thus,
counter the forgetting curve. This is termed as *Spaced Repitition*.
#+CAPTION:Ebbinghaus' forgetting curve countered by Spaced Repition
#+attr_latex: :height 200px
#+attr_org: :height 200px
[[file:../proposal/diagrams/forgetting-curve-spaced-repitition.png]]
#+LATEX:\FloatBarrier

*** SM-2 algorithm
SuperMemo is a learning software that implements the afore-mentioned methods. It uses an underlying algorithm for
calculating when the next repitition/ revision date for a flashcard should be. The algorithm differs across versions
but the SM-2 algorithm[cite:@sm_2] is popular among other flashcard software. A slightly modified version of SM-2 (used in CardsQL)
is described below. 

While practicing flashcards, users can rate how well they were able to remember the answer.
The rating/ quality of a review is represented by =Q=.

#+CAPTION: Meanings of flashcard rating values
|---+-----------+------------------------------|
|   | rating(Q) | meaning                      |
|---+-----------+------------------------------|
| / |         < | <>                           |
|   |         0 | Forgot                       |
|   |         1 | Partially remembered         |
|   |         2 | Remembered after some effort |
|   |         3 | Remembered easily            |
|---+-----------+------------------------------|

SM-2 also tracks three properties for all cards: 

- The repetition number =N=, which is the consecutive number of times the card has been successfully recalled
  (meaning Q \ge 2).  Rating a card below 2 will thus reset =N= to 0.
- The interval =I=, which is the number of days after which the card should be reviewed again (to negate the forgetting
  curve). CardsQL sets next review date = previous review date(today) + =I=.
- The easiness factor =EF=, which loosely indicates how "easy" the card is (More precisely, it determines how quickly the
  interval grows). The initial value of =EF= for all cards is 2.5.

  Due to the formula used, =EF= value should be ~>=1.3~ so that a card's review isn't scheduled too frequently and isn't too easy.
  Similarly, it should be ~<=2.5~ so that it isn't scheduled so far into the future that we've forgotten the answer completely by then. 

The main algorithm is as follows:
# algorithm isn't actually ruby code. I just specified the language for syntax highlighting
#+BEGIN_SRC ruby
  input:  user rating(Q),  repetition number(N),  easiness factor(EF),  interval(I)
  output: updated values of N, EF, I

  if Q >= 2 (i.e. correct response) then
      if N = 0 then  I = 1
      else if N = 1 then  I = 6
      else I = round(I × EF)
      end if
      increment n
  else (incorrect response)
      N = 0
      I = 1
  end if

  EF = EF + (0.1 - (4 - Q) × (0.09 + (4 - Q) × 0.03))
  if EF < 1.3 then  EF = 1.3
  else if EF > 2.5 then  EF = 2.5
  end if
  return (N, EF, I)
#+END_SRC

When revising cards on a particular day, CardsQL will show you cards that are scheduled for that day or older(for overdue cards).
** Literature Review
# review of similar projects 
*** Study of existing system
Two popular flashcard apps are:

**** Quizlet
***** Pros
- pre-made flashcards for subjects
- emphasis on mobile version UX which allows users to revise anytime, anywhere
- utilizes machine learning from anonymous user-data to create custom study plans for users
***** Cons
- free version has ads & lacks advanced features
- can't be used offline on free version

**** Anki
***** Pros
- Free & Open Source Software (FOSS)
- supports sync between multiple devices
- highly customizable with user-defined card types & community-made plugins
***** Cons
- complex from start;
  CardsQL can act as gateway/ introduction to flashcards. Users can transition to Anki later
- might have to spend a lot of time customizing the program, adding plugins, to get a good experience
* System Analysis and Design
** System Analysis
*** Requirement Analysis
**** Functional requirements    

*Note:* /As CardsQL is meant for personal use, it only has one type of user instead of admin, multiple users etc./
***** User
- can add cards
- can revise due cards
- can edit text & review date of existing cards
# - can revise cards regardless of due date (for pre-exam practice)
# - can reset review date for all cards
**** Use Case diagram

#+begin_src plantuml :file diagrams/use-case-diagram.svg
  @startumL
  skinparam 300 dpi
  skinparam packageStyle rectangle
  actor user as u
  rectangle System {
          (Create Cards) as (CC)
          (Revise Cards) as (RC)
          (Edit Cards) as (EC)
          (Delete Cards) as (DC)
          u -up- (CC)
          u -up- (RC)
          u -up- (EC)
          (RC) .left.> (CC) :<<includes>>
          (DC) .left.> (EC) :<<extends>>
  }
  @enduml
#+end_src

#+RESULTS:
#+CAPTION: Use case diagram for CardsQL
#+attr_latex: :width 400px
#+attr_org: :width 400pX
[[file:diagrams/use-case-diagram.svg]]

#+LATEX:\FloatBarrier
**** Non-Functional requirements
- *offline access to all features*
  #+LATEX:\\
  /Achieved by hosting php server & storing data both on user's computer/
- *simple to use*
  #+LATEX:\\
  /First thing user sees is just card creation interface/
- *User shouldn't have to review too many cards in a day*
  #+LATEX:\\
  /User can set daily card goal/limit/
# - regular data backups
  # sql has built-in backup command/ functionality
  # option to clean up old backup files
*** Feasibiliity Analysis
**** *Technical*
\\
CardsQL is not too difficult to implement from a technical standpoint because it uses:

- plain HTML, CSS for the front-end
- basic JavaScript and PHP for the busienss logic
- SQLite, a lightweight RDBMS, for the database. It uses a single database file on the user's computer
  so it negates the need for maintaining a server for users to connect to.
#+LATEX: \clearpage
***** COMMENT similar stuff is written in Tools USed. differentiate here?
**** *Operational*
- Because of the self-hosted architecture, the app will work offline without needing to connect to a central server.
  Thus, there is no need to designate manpower to ensure the app stays operational after launch.
- Users are sure to adopt the app as it is more convenient than paper flashcards, while still being easier to pick up and learn than the advanced programs discussed in
  *[[*Study of existing system][Study of existing system]]*
**** *Economic*
\\
CardsQl is viable from an economic standpoint as:

- There are no additional costs for web hosting, server maintenance etc.
- There were no development costs as the app was built using existing hardware & freely-licensed tools. 
- The app is distributed freely to help users & doesn't have any profit incentives.

*** Data Modeling
*Note:* /The database is only used for storing cards along with their metadata. As it is meant to be used by a single-user
, there is no need to implement or store login credentials./
# (E-R diagram)

#+CAPTION: Entity-Relationship diagram for CardsQL
#+attr_latex: :height 150px
#+attr_org: :height 150px
[[file:diagrams/cardsql-er-diagram.svg]]
*** Proces Modeling(DFD)
#+CAPTION: Data Flow Diagram diagram for CardsQL
#+attr_latex: :height 150px
#+attr_org: :height 150px
[[file:diagrams/cardsql-dfd.svg]]
#+LATEX:\FloatBarrier
** System Design
*** Architectural Design
#+CAPTION: Architectural design for CardsQL
#+attr_latex: :height 200px
#+attr_org: :height 200px
[[file:diagrams/cardsql-architecture-design.svg]]

*** Database Schema Design 
*Note*: /In SQLite, =text= and =varchar= data type are the same and allocate space according to value's lenght. =real= data tpye refers to floating-point numbers/
#+begin_src plantuml :file diagrams/database-schema.svg 
@startuml
entity "cards" {
  {static} *id : int <<primary>>
  *front : text
  *back : text
  *direction : int
  *successfulRevisions: int 
  *easeFactor: real  
  *interval: int
  *scheduledDate: text 
}
@enduml
#+end_src

#+RESULTS:
#+CAPTION: Database schema for CardsQL
#+attr_latex: :height 200px
#+attr_org: :height 200px
[[file:diagrams/database-schema.svg]]
#+LATEX: \FloatBarrier

*** Interface Design
# (UI Interface/ Interface Structure Diagrams)
Due to the app's simple nature, User Interface(UI) designs were not made beforehand. Styling was decided on during
development, and applied after implementing correct business logic.
*** Physical DFD
The following Data Flow Diagram goes more in-depth than the previous diagram, and reflects how some processes are
performed/implemented technically.
#+CAPTION: Physical DFD for CardsQL
#+attr_latex: :height 210px
#+attr_org: :height 210px
[[file:diagrams/cardsql-physical-dfd.svg]]
#+LATEX:\FloatBarrier
* Implementation and Testing
** Implementation
*** Tools Used
# (CASE tools, Programming languages, Database )
The following Computer Aided Software Engineering(CASE) tools were used during the project's development:
**** Presentation layer
- HTML was used for structuring the webpage and its contents.
- Plain CSS, i.e. without any frameworks, was used for appplying styling and decorations.
**** Logic layer
- JavaScript is used for client-side interactivity & DOM manipulation such as showing card answer only when button is
  clicked, populating edit dialog's values according to selected card etc.
- PHP is used for server-side scripting, i.e., mainly for performing \acrfull{crud} operations on the database.   
  Installing the language also allows us to use its basic, local web server, which is suitable for running CardsQL. 
  This was used during development instead of dedicated server software like Apache.
**** Data layer:
- SQLite is a lightweight \acrfull{rdbms}  used for our database purposes.
  It uses a single database file on the user's computer so it negates the need for maintaining an SQL server.
**** Miscellaneous:
- Git was used for version control, while Github served as a remote backup for the code.
*** Implementation Details of Modules
The different possible actions and how they are implemented are as follows:
# (Description of procedures/ functions)
**** *Add flashcards*
\\
The homepage allows a user to add a new flashcard by specifying the text contents of its front and back side in an html
form. Upon submitting the form, the contents are sent to the web server using an \acrfull{http} request.
PHP code intercepts it and inserts a new row in the database table. Each row in the table represents a flashcard.
Metadata values for newly created card such as the =Interval, EaseFactor= are set using default constraints defined
in the table schema.

**** *Review flashcards*
\\
In the review page, php code retrieves flashcards that have a due date of today or older, one at a time. Only the
question(content of front side) is shown first and the user is prompted to recall the answer. They can press a button
to show the correct answer and rate how well they remembered it on a scale of 0 to 3. The rating is sent to the web
server and php code uses it to update the card's metadata using the =SM-2= algorithm discussed previously. This process
continues until no due cards are left.

**** *Edit flashcards*
\\
The edit page initially shows a table of all the cards in the database. Clicking on a row will bring up a modal dialog 
for editing the selected card. The dialog has a form whose values are populated with the selected card using javascript.
Confirming edits will submit the form and php code will execute =UPDATE= SQL statement on the database accordingly.
The dialog also has a delete button which will tell php to execute a =DELETE= SQL statement instead.
** Testing
*** Test cases for Unit(Manual) Testing
The test cases and how they were implemented programatically are as follows:

- User shouldn't leave either side of card empty while creating. Implemented with =required= attribute in HTML form and
  =NOT NULL= constraint in dtabase schema.

- While reviewing a cards, rating value should be between 0 and 3. Implemented by having form inputs with only this
  set of values. In case its value is somehow outside that range, the follwing php code is put in place to keep it inside
  the 0-3 range.
  #+begin_src php
    $rating = $rating < 0 ? 0 : ($rating > 3 ? 3 : $rating);
  #+end_src
  If rating is below, it's set to 0 and if it is above 3 it's set to 3.

- =EaseFactor= should similarly stay between 1.3 and 2.5 for most effectivenes, according to the algorithm. Code similar
  to above is used to keep this value in check.
  
* Conclusion and Future Recommendation
** Lesson learnt/ Outcome
** Conclusion
** Future recommendation
* Apendix
# screenshots
# supervisor visit log sheets (lmaooooo)
* References and Bibliography
#+cite_export: csl ~/.emacs.d/packages/ieee.csl
#+LATEX: \setlength{\parindent}{0cm}
#+PRINT_BIBLIOGRAPHY:
